(*
 * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)
 *
 * SPDX-License-Identifier: GPL-2.0-only
 *)
chapter \<open>\label{h:procbase}Example -- Procedures\<close>
(*<*)
(* THIS FILE IS AUTOMATICALLY GENERATED. YOUR EDITS WILL BE OVERWRITTEN. *)
theory GenSimpleBase
imports "Types" "Abbreviations" "Connector"
begin
(*>*)

text \<open>
  In this section we provide an example of the generated types and definitions
  that are derived from a \camkes procedure interface. Throughout, this
  section uses an example system involving two components defined by the
  following \camkes specification:

  \camkeslisting{simple.camkes}

  The system can be depicted as two components connected with a single
  interface, in \autoref{fig:echo}.

  \begin{figure}[h]
    \begin{center}
      \includegraphics[width=300px]{imgs/echo}
    \end{center}
    \caption{\label{fig:echo}Hello world}
  \end{figure}

  The types and definitions presented in this section are semantically
  identical to those
  generated for the system above. However, the order in which entities are
  introduced and the white space has been modified for better readability.

\<close>

subsection \<open>\label{ssec:procbase}Generated Base Theory\<close>

subsubsection \<open>\label{sssec:procbasetypes}Types\<close>
text \<open>
  Data types are generated to enumerate the connections in the system,
  @{term channel}, and the component instances in the system, @{term inst}. As
  this system only has a single connection, the @{term channel} data type is
  trivial. Note that the @{term inst} type enumerates component
  \emph{instances}, not component \emph{types}.
\<close>

datatype channel
  = simple

datatype inst
  = client
  | echo

text \<open>
  For each component type, a data type is generated that enumerates the
  interfaces of that component.
\<close>

datatype Client_channel
  = Client_s

datatype Echo_channel
  = Echo_s

text \<open>
  This type does not indicate whether the
  interfaces are outgoing or incoming, or what type of interface they
  represent. All component type definitions are parameterised with a mapping
  from this type to @{term channel}. When a component type is instantiated,
  this mapping must be specified to describe the architecture of the system. In
  this example system, both component instances each have their single
  interface mapped to the only connection, @{term simple}.
\<close>

subsubsection \<open>\label{sssec:procbaseprim}Interface Primitives\<close>
text \<open>
  This section describes the glue code specifications generated for each
  interface of each component type. For
  an outgoing procedure interface, a definition is generated for each method
  in that interface, prefixed by ``Call'', the component name and the interface
  name. These can be composed with each other and user-provided steps to form
  a process that describes the execution of the component.

  The interface in this example has three methods, @{term echo_string},
  @{term echo_int} and @{term echo_parameter}, hence three separate call
  definitions are generated. These functions take a sequence of embedding and
  projection functions into and out of the component's local state. The types
  of these functions are derived from the parameter types of the method and are
  used for marshalling arguments.

  For example, @{term echo_string} takes a
  @{term smallstring} input parameter, @{term s}, which necessitates a
  projection function, @{term s\<^sub>P}, as a parameter to
  @{term Call_Client_s_echo_string}. Conversely, the method returns a
  @{term smallstring} parameter, necessitating an embedding function,
  @{term embed} as a parameter. In general, an input parameter requires a
  projection, an output parameter or return value requires an
  embedding and an input/output parameter requires both.
\<close>

definition
  Call_Client_s_echo_string :: "(Client_channel \<Rightarrow> channel) \<Rightarrow>
    ('cs local_state \<Rightarrow> string) \<Rightarrow>
    ('cs local_state \<Rightarrow> string \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_Client_s_echo_string ch s\<^sub>P embed_data \<equiv>
    Request (\<lambda>s. {\<lparr>q_channel = ch Client_s,
      q_data = Call 0 (String (s\<^sub>P s) # [])\<rparr>}) discard ;;
    Response (\<lambda>q s. case q_data q of Return xs \<Rightarrow>
      {(embed_data s (case hd xs of String v \<Rightarrow> v),
      \<lparr>a_channel = ch Client_s, a_data = Void\<rparr>)} | _ \<Rightarrow> {})"

definition
  Call_Client_s_echo_int :: "(Client_channel \<Rightarrow> channel) \<Rightarrow>
    ('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_Client_s_echo_int ch i\<^sub>P embed_data \<equiv>
    Request (\<lambda>s. {\<lparr>q_channel = ch Client_s,
      q_data = Call 1 (Integer (i\<^sub>P s) # [])\<rparr>}) discard ;;
    Response (\<lambda>q s. case q_data q of Return xs \<Rightarrow>
      {(embed_data s (case hd xs of Integer v \<Rightarrow> v),
      \<lparr>a_channel = ch Client_s, a_data = Void\<rparr>)} | _ \<Rightarrow> {})"

definition
  Call_Client_s_echo_parameter :: "(Client_channel \<Rightarrow> channel) \<Rightarrow>
    ('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_Client_s_echo_parameter ch pin\<^sub>P embed_data \<equiv>
    Request (\<lambda>s. {\<lparr>q_channel = ch Client_s,
      q_data = Call 2 (Integer (pin\<^sub>P s) # [])\<rparr>}) discard ;;
    Response (\<lambda>q s. case q_data q of Return xs \<Rightarrow>
      {(embed_data s (case hd xs of Integer v \<Rightarrow> v) (case xs ! 1 of Integer v \<Rightarrow> v),
      \<lparr>a_channel = ch Client_s, a_data = Void\<rparr>)} | _ \<Rightarrow> {})"

text \<open>
  For an incoming procedure interface, a single definition is generated with
  the prefix ``Recv'', the component's name and the interface name. There is a
  single defintion on the incoming side, rather than one per interface, to
  match the semantics of the implementation. That is, the blocking receive
  followed by method dispatch are captured in this definition. Projection and
  embedding functions are again necessitated, but their roles are reversed.

  Each receive definition is also parameterised with a process for each method
  representing the user-provided implementation of this method. For example, in
  the definition below, the @{term Echo_s_echo_string} parameter is expected to
  be the
  user's implementation of the @{term echo_string} method.
\<close>

definition
  Recv_Echo_s :: "(Echo_channel \<Rightarrow> channel) \<Rightarrow>
    ('cs local_state \<Rightarrow> string \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp \<Rightarrow> ('cs local_state \<Rightarrow> string) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp \<Rightarrow> ('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow> (channel, 'cs) comp \<Rightarrow>
    ('cs local_state \<Rightarrow> int) \<Rightarrow> ('cs local_state \<Rightarrow> int) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Recv_Echo_s ch echo_string\<^sub>E Echo_s_echo_string echo_string_return\<^sub>P
     echo_int\<^sub>E Echo_s_echo_int echo_int_return\<^sub>P echo_parameter\<^sub>E
     Echo_s_echo_parameter echo_parameter_return\<^sub>P echo_parameter_pout\<^sub>P \<equiv>
    (Response (\<lambda>q s. case q_data q of Call n xs \<Rightarrow>
      (if n = 0 then {(echo_string\<^sub>E s (case xs ! 0 of String v \<Rightarrow> v),
        \<lparr>a_channel = ch Echo_s, a_data = Void\<rparr>)} else {}) | _ \<Rightarrow> {}) ;;
     Echo_s_echo_string ;;
     Request (\<lambda>s. {\<lparr>q_channel = ch Echo_s,
       q_data = Return (String (echo_string_return\<^sub>P s) # [])\<rparr>}) discard)
    \<squnion>
    (Response (\<lambda>q s. case q_data q of Call n xs \<Rightarrow>
      (if n = 1 then {(echo_int\<^sub>E s (case xs ! 0 of Integer v \<Rightarrow> v),
        \<lparr>a_channel = ch Echo_s, a_data = Void\<rparr>)} else {}) | _ \<Rightarrow> {}) ;;
     Echo_s_echo_int ;;
     Request (\<lambda>s. {\<lparr>q_channel = ch Echo_s,
       q_data = Return (Integer (echo_int_return\<^sub>P s) # [])\<rparr>}) discard)
    \<squnion>
    (Response (\<lambda>q s. case q_data q of Call n xs \<Rightarrow>
      (if n = 2 then {(echo_parameter\<^sub>E s (case xs ! 0 of Integer v \<Rightarrow> v),
        \<lparr>a_channel = ch Echo_s, a_data = Void\<rparr>)} else {}) | _ \<Rightarrow> {}) ;;
     Echo_s_echo_parameter ;;
     Request (\<lambda>s. {\<lparr>q_channel = ch Echo_s,
       q_data = Return (Integer (echo_parameter_return\<^sub>P s) #
                        Integer (echo_parameter_pout\<^sub>P s) # [])\<rparr>}) discard)"

subsubsection \<open>\label{sssec:procbaseinst}Instantiations of Primitives\<close>
text \<open>
  With the component type definitions in place, the definitions of component
  instance primitives  are much simpler as they are partial applications of the
  component
  type definitions. A call definition is generated for each method in each
  outgoing interface in each
  component instance that partially applies the call definitions described in
  \autoref{sssec:procbaseprim} with a mapping from the component's interface to
  the system connection.

  The parameter used to specialise the component primitives, a function from
  that component's channel type to the system channel type, is derived from the
  architecture of the system. In this example the instance @{term client} has
  its interface @{term s} connected to the connection @{term simple}. Thus its
  primitives are expressed using a function that maps its channel type
  @{term Client_s} to the corresponding system channel, @{term simple}. In the
  case of this example where the @{term client} instance has a single
  interface, the function could be given as @{term "\<lambda>_. simple"}, but for
  simplicity the generator does not make this optimisation.
\<close>

definition
  Call_client_s_echo_string :: "('cs local_state \<Rightarrow> string) \<Rightarrow>
    ('cs local_state \<Rightarrow> string \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_client_s_echo_string \<equiv>
    Call_Client_s_echo_string (\<lambda>c. case c of Client_s \<Rightarrow> simple)"

definition
  Call_client_s_echo_int :: "('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_client_s_echo_int \<equiv>
    Call_Client_s_echo_int (\<lambda>c. case c of Client_s \<Rightarrow> simple)"

definition
  Call_client_s_echo_parameter :: "('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp"
where
  "Call_client_s_echo_parameter \<equiv>
    Call_Client_s_echo_parameter (\<lambda>c. case c of Client_s \<Rightarrow> simple)"

text \<open>
  Similarly, a receive definition is generated for each
  incoming interface in each component instance.
\<close>

definition
  Recv_echo_s :: "('cs local_state \<Rightarrow> string \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp \<Rightarrow> ('cs local_state \<Rightarrow> string) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp \<Rightarrow> ('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int \<Rightarrow> 'cs local_state) \<Rightarrow>
    (channel, 'cs) comp \<Rightarrow> ('cs local_state \<Rightarrow> int) \<Rightarrow>
    ('cs local_state \<Rightarrow> int) \<Rightarrow> (channel, 'cs) comp"
where
  "Recv_echo_s \<equiv> Recv_Echo_s (\<lambda>c. case c of Echo_s \<Rightarrow> simple)"

(*<*)
end
(*>*)
